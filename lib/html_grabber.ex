defmodule HtmlGrabber do
  @moduledoc """
  This module allows us to extract "between" two ID's, using in-order traversal of the HTML tree.

  So unfortunately, Floki doesn't allow us to extract text "between" nodes. This means that I (Ash) had to write my own method to traverse the tree and extract all HTML text between filings.

  ## Technical Details
  Some `Floki.html_node()`s are purely text, and others are nested tags. We want to traverse the nodes in order, and gradually build our extracted string from the string slices "captured" from each node. Therefore, when we call `scan` on a node, we always want to get back a string (plus metadata), which we can feed into the next call to `scan`, recursing through our the nodes one by one.

  To demonstrate why we couldn't use any "official" Floki methods: Let's say that we have an element `X` that contains `A`, `B`, and `C`, and that we want to capture text start. We want to extract `B` and `C`, but we can't directly call `Floki.text()` on `X`, since we would get `A` too.

  We also can't perform any "tricks" with the relative positions of tags, since the HTML structure is *extremely inconsistent* from one filing to another, with next-to-no standardization.

  Therefore, our solution is to 1) traverse the nodes in-order, 2) set an "capture?" flag to true when we encounter the starting id, and 3) build the string by passing the result (current string + capture? option) from one node to the next, until 4) we find the ending id and return our result.
  """

  defmodule Result do
    @moduledoc """
    This struct was created based on my mathematical model of HTML extraction.

    It stores the string that is currently being built, as well as "flags"
      containing relevant information about previous operations
    """
    defstruct capture?: false, str: ""
    @type t :: %Result{capture?: boolean(), str: binary()}
  end

  @doc """
  This function recursively scans the HTML node in order, and builds a string starting from `start_id` to `fnish_id`

  ## Summary of Method
  The function essentially takes in an HTML node, traverses its children, scans the children (causing recursion), and then feeds the result from the last scan into the next scan.
  This "result" (i.e. `ExtractBetweenIds.Result`) is just a struct that includes 1) the string that is currently being built, and 2) a flag called `capture?`. (We only concatenate the string if this "capture?" flag is set.)

  Thus, the function traverses the tree in order, then when it finds the ID, it sets `capture?` to `true`. Until `capture?` is set back to `false`, the following nodes thus concatenate their node's extracted text.

  """
  @spec scan_between(
          nodes :: list(Floki.html_node()),
          start_id :: binary(),
          fnish_id :: binary(),
          # Result from previous call
          now :: Result.t()
        ) :: Result.t()

  def scan_between([], _start_id, _fnish_id, final_result), do: final_result
  # Clauses for when we hit text nodes: just concatenate the text (maybe)
  def scan_between([node | next], start_id, fnish_id, now = %Result{capture?: true})
      when is_binary(node) do
    scan_between(next, start_id, fnish_id, %Result{now | str: now.str <> node})
  end

  def scan_between([node | next], start_id, fnish_id, now = %Result{capture?: false})
      when is_binary(node) do
    scan_between(next, start_id, fnish_id, now)
  end

  # Do nothing for comments
  def scan_between([{:comment, _} | next], start_id, fnish_id, now) do
    scan_between(next, start_id, fnish_id, now)
  end

  # Clause for tag node: scan through children next
  def scan_between([node | next], start_id, fnish_id, now) do
    start_capture? =
      case Floki.attribute(node, "id") do
        [^start_id] -> true
        [^fnish_id] -> false
        _no_change -> now.capture?
      end

    new_result = %Result{now | capture?: start_capture?}

    # In order traversal: Search for deepest-left child first
    children_next = Floki.children(node) ++ next
    scan_between(children_next, start_id, fnish_id, new_result)
  end

  @doc """
  This function is the "interface" to process HTML Trees generated by Floki, and extract text between `start_id` and `fnish_id`.

  It's like a wrapper on `ExtractBetweenIds.scan_between()`, but translates private module structs from/into normal ASCII binaries.
  """
  @spec grab_between(Floki.html_tree(), binary(), binary()) :: binary()
  def grab_between(html_tree, start_id, fnish_id) do
    root_node = Floki.find(html_tree, "html") |> List.first()

    initial_result = %Result{
      str: "",
      capture?: false
    }

    final_result = HtmlGrabber.scan_between([root_node], start_id, fnish_id, initial_result)
    final_result.str
  end
end
